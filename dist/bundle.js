/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./scripts/constants.js":
/*!******************************!*\
  !*** ./scripts/constants.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessibleColors: () => (/* binding */ accessibleColors),\n/* harmony export */   backgroundColors: () => (/* binding */ backgroundColors)\n/* harmony export */ });\nconst accessibleColors = [\r\n    { color: \"#FF0000\", number: 1 },\r\n    { color: \"#00FF00\", number: 2 },\r\n    { color: \"#0000FF\", number: 3 },\r\n    { color: \"#FFFF00\", number: 4 },\r\n    { color: \"#FF00FF\", number: 5 },\r\n    { color: \"#00FFFF\", number: 6 },\r\n    { color: \"#800000\", number: 7 },\r\n    { color: \"#808000\", number: 8 },\r\n    { color: \"#008000\", number: 9 },\r\n    { color: \"#800080\", number: 10 },\r\n    { color: \"#008080\", number: 11 },\r\n    { color: \"#000080\", number: 12 },\r\n    { color: \"#FFA500\", number: 13 },\r\n    { color: \"#A52A2A\", number: 14 },\r\n    { color: \"#8A2BE2\", number: 15 },\r\n    { color: \"#5F9EA0\", number: 16 },\r\n];\r\n\r\nconst backgroundColors = [\r\n    '#FF0000', // Red\r\n    '#FF4500', // Reddish Orange\r\n    '#FFA500', // Orange\r\n    '#FFFF00', // Yellow\r\n    '#ADFF2F', // Yellowish Green\r\n    '#00FF00', // Green\r\n    '#00FA9A', // Aquamarine\r\n    '#00FFFF', // Cyan\r\n    '#1E90FF', // Dodger Blue\r\n    '#0000FF', // Blue\r\n    '#4B0082', // Indigo\r\n    '#8A2BE2', // Violet (closer to red again)\r\n];\r\n\n\n//# sourceURL=webpack://colorgame/./scripts/constants.js?");

/***/ }),

/***/ "./scripts/helpers.js":
/*!****************************!*\
  !*** ./scripts/helpers.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawCloud: () => (/* binding */ drawCloud),\n/* harmony export */   drawTriangle: () => (/* binding */ drawTriangle),\n/* harmony export */   mixColors: () => (/* binding */ mixColors)\n/* harmony export */ });\n\n// Helper function to blend two colors\nfunction mixColors(color1, color2) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = color1;\n    ctx.fillRect(0, 0, 1, 1);\n    const c1 = ctx.getImageData(0, 0, 1, 1).data;\n\n    ctx.fillStyle = color2;\n    ctx.fillRect(0, 0, 1, 1);\n    const c2 = ctx.getImageData(0, 0, 1, 1).data;\n\n    const mixed = {\n        r: Math.round((c1[0] + c2[0]) / 2),\n        g: Math.round((c1[1] + c2[1]) / 2),\n        b: Math.round((c1[2] + c2[2]) / 2)\n    };\n\n    return `rgb(${mixed.r}, ${mixed.g}, ${mixed.b})`;\n}\n\nfunction drawCloud(ctx, x, y, baseRadius) {\n    const scaleFactor = 1.5; // Scale factor to make clouds bigger\n    const radius = baseRadius * scaleFactor;\n\n    ctx.beginPath();\n    ctx.arc(x - radius / 2, y, radius / 2, Math.PI * 0.5, Math.PI * 1.5);\n    ctx.arc(x, y - radius / 2, radius / 2, Math.PI, Math.PI * 2);\n    ctx.arc(x + radius / 2, y, radius / 2, Math.PI * 1.5, Math.PI * 0.5);\n    ctx.closePath();\n    ctx.fill();\n}\n\n\nfunction drawTriangle(ctx, x, y, size) {\n    const scaleFactor = 1.3; // Scale factor for enlarging triangles\n    const adjustedSize = size * scaleFactor;\n    const height = (Math.sqrt(3) / 2) * adjustedSize; // Calculate the height of the scaled triangle\n\n    // Draw the triangle\n    ctx.beginPath();\n    ctx.moveTo(x, y - height / 2); // Top vertex\n    ctx.lineTo(x - adjustedSize / 2, y + height / 2); // Bottom-left vertex\n    ctx.lineTo(x + adjustedSize / 2, y + height / 2); // Bottom-right vertex\n    ctx.closePath();\n    ctx.fill();\n\n    // Calculate the centroid for text alignment\n    const centroidX = x;\n    const centroidY = y + height / 6; // Adjust vertically for better centering\n\n    return { centroidX, centroidY }; // Return centroid for text placement\n}\n\n\n\n\n//# sourceURL=webpack://colorgame/./scripts/helpers.js?");

/***/ }),

/***/ "./scripts/init.js":
/*!*************************!*\
  !*** ./scripts/init.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./scripts/constants.js\");\n/* harmony import */ var _target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./target.js */ \"./scripts/target.js\");\n/* harmony import */ var _particle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./particle.js */ \"./scripts/particle.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"./scripts/helpers.js\");\n\r\n\r\n\r\n\r\n\r\nclass Game {\r\n    constructor() {\r\n        this.canvas = document.getElementById('gameCanvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.startTime = null; // Track when the game starts\r\n        this.score = 0;\r\n        this.level = 1;\r\n        this.player = {};\r\n        window.player = this.player;\r\n        this.targets = [];\r\n        this.particles = [];\r\n        this.gameActive = false;\r\n        this.currentBgIndex = 0; // Start with the first color\r\n        this.nextBgIndex = 1; // Keep track of the next color for transitions    \r\n        this.setupStartButton();\r\n        window.addEventListener('resize', () => this.resize());\r\n    }\r\n    \r\n    setupPlayer(player){   \r\n        player = { x: 0, y: 0, size: 40, color: '#0000FF', number: 1 }; \r\n        return player;\r\n    }\r\n\r\n\r\n    setupStartButton() {\r\n        const startButton = document.getElementById('startButton');\r\n        startButton.addEventListener('click', () => {\r\n            this.initializeGame();\r\n        });\r\n    }\r\n\r\n    setup() {\r\n        this.startTime = Date.now(); // Record start time\r\n        this.resize();\r\n        this.targets = [];\r\n        this.particles = [];\r\n        this.spawnTargets();        \r\n        this.player = this.setupPlayer(this.player);\r\n        this.setupInteractionEvents();\r\n        this.gameActive = true;\r\n        this.startBackgroundUpdate();\r\n    }\r\n\r\n    initializeGame() {\r\n        console.log('Initializing game...');\r\n        document.getElementById('startButton').style.display = 'none'; // Hide the start button\r\n        this.level = 1; // Reset level\r\n        this.score = 0; // Reset score               \r\n        this.setup(); // Reinitialize the game\r\n        this.gameLoop();\r\n    }\r\n    \r\n\r\n    endGame() {\r\n        console.log('Game over!');\r\n    \r\n        // Stop the game loop\r\n        this.gameActive = false;\r\n    \r\n        // Calculate the duration\r\n        const duration = Math.floor((Date.now() - this.startTime) / 1000); // Convert to seconds\r\n    \r\n        // Display the game-over overlay\r\n        const gameOverOverlay = document.getElementById('gameOver');\r\n        const finalScoreElement = document.getElementById('finalScore');\r\n        const finalLevelElement = document.getElementById('finalLevel');\r\n        const finalTimeElement = document.getElementById('finalTime');\r\n    \r\n        finalScoreElement.textContent = this.score;\r\n        finalLevelElement.textContent = this.level;\r\n        finalTimeElement.textContent = `${duration} seconds`;\r\n    \r\n        gameOverOverlay.style.display = 'block';\r\n    \r\n        // Add event listener for Play Again button\r\n        const restartButton = document.getElementById('restartButton');\r\n        restartButton.onclick = () => {\r\n            gameOverOverlay.style.display = 'none'; // Hide the overlay\r\n            this.initializeGame(); // Reuse game initialization logic\r\n        };\r\n    }\r\n    \r\n    \r\n\r\n\r\n    resize() {\r\n        console.log('Resizing canvas');\r\n        this.canvas.width = window.innerWidth;\r\n        this.canvas.height = window.innerHeight;\r\n    }\r\n\r\n    spawnTargets() {\r\n        console.log('Spawning targets');\r\n        this.targets = []; // Clear existing targets\r\n    \r\n        const maxRegularTargets = 10;\r\n        const margin = 50; // Avoid spawning too close to canvas edges\r\n    \r\n        for (let i = 0; i < maxRegularTargets; i++) {\r\n            const currentNumber = (2 + i - 1) % _constants_js__WEBPACK_IMPORTED_MODULE_0__.accessibleColors.length + 1;\r\n            const targetColor = _constants_js__WEBPACK_IMPORTED_MODULE_0__.accessibleColors.find((c) => c.number === currentNumber);\r\n    \r\n            const randomX = margin + Math.random() * (this.canvas.width - 2 * margin);\r\n            const randomY = margin + Math.random() * (this.canvas.height - 2 * margin);\r\n    \r\n            this.targets.push(new _target_js__WEBPACK_IMPORTED_MODULE_1__.Target(this.canvas, 2 + Math.random() * 3, targetColor, 'regular', randomX, randomY));\r\n            console.log(`Spawned target with number: ${targetColor.number}`);\r\n        }\r\n    \r\n        const hazardCount = Math.min(this.level, 5);\r\n        for (let i = 0; i < hazardCount; i++) {\r\n            const randomX = margin + Math.random() * (this.canvas.width - 2 * margin);\r\n            const randomY = margin + Math.random() * (this.canvas.height - 2 * margin);\r\n    \r\n            this.targets.push(new _target_js__WEBPACK_IMPORTED_MODULE_1__.Target(this.canvas, 3 + Math.random() * 2, { color: \"#000000\", number: -1 }, 'hazard', randomX, randomY));\r\n            console.log('Spawned hazard target');\r\n        }\r\n    }\r\n    \r\n\r\n    setupInteractionEvents() {\r\n        console.log('Setting up interaction events');\r\n    \r\n        // Mouse events\r\n        this.canvas.addEventListener('mousemove', (event) => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            this.player.x = event.clientX - rect.left - this.player.size / 2;\r\n            this.player.y = event.clientY - rect.top - this.player.size / 2;\r\n        });\r\n    \r\n        // Touch events\r\n        this.canvas.addEventListener('touchmove', (event) => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            const touch = event.touches[0]; // Get the first touch point\r\n            this.player.x = touch.clientX - rect.left - this.player.size / 2;\r\n            this.player.y = touch.clientY - rect.top - this.player.size / 2;\r\n    \r\n            event.preventDefault(); // Prevent scrolling during gameplay\r\n        });\r\n    \r\n        this.canvas.addEventListener('touchstart', (event) => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            const touch = event.touches[0];\r\n            this.player.x = touch.clientX - rect.left - this.player.size / 2;\r\n            this.player.y = touch.clientY - rect.top - this.player.size / 2;\r\n    \r\n            event.preventDefault(); // Prevent scrolling during gameplay\r\n        });\r\n    \r\n        this.canvas.addEventListener('touchend', () => {\r\n            console.log('Touch ended');\r\n        });\r\n    \r\n        // Interval for collision checking\r\n        setInterval(() => {\r\n            this.checkCollisions();\r\n        }, 50); // Check collisions every 50ms\r\n    \r\n        console.log('Interaction events and collision checking interval set up');\r\n    }\r\n    \r\n\r\n    startBackgroundUpdate() {\r\n        console.log('Starting background color update');\r\n        setInterval(() => {\r\n            // Use CSS transitions for smoother updates\r\n            const canvas = this.canvas;\r\n            const currentColor = _constants_js__WEBPACK_IMPORTED_MODULE_0__.backgroundColors[this.currentBgIndex];\r\n            const nextColor = _constants_js__WEBPACK_IMPORTED_MODULE_0__.backgroundColors[this.nextBgIndex];\r\n    \r\n            // Apply transition effect using CSS\r\n            canvas.style.transition = 'background-color 2s ease-in-out';\r\n            canvas.style.backgroundColor = currentColor;\r\n    \r\n            // Cycle through colors\r\n            this.currentBgIndex = this.nextBgIndex;\r\n            this.nextBgIndex = (this.nextBgIndex + 1) % _constants_js__WEBPACK_IMPORTED_MODULE_0__.backgroundColors.length;\r\n    \r\n            console.log(`Background color updated to: ${currentColor}`);\r\n        }, 5000); // Change background every 5 seconds\r\n    }\r\n    \r\n\r\n    updateParticles() {\r\n        this.particles.forEach((particle) => particle.update());\r\n        this.particles = this.particles.filter((particle) => particle.life > 0);\r\n    }\r\n\r\n    drawParticles() {\r\n        this.particles.forEach((particle) => particle.draw(this.ctx));\r\n    }\r\n\r\n    drawHintLine() {\r\n        const validTarget = this.targets.find(target => target.number !== -1 && Math.abs(target.number - this.player.number) === 1);\r\n        if (validTarget) {\r\n            const dx = validTarget.x - this.player.x;\r\n            const dy = validTarget.y - this.player.y;\r\n            const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            const lineThickness = Math.max(1, 10 - (distance / 50)); // Thicker line when closer\r\n\r\n            this.ctx.lineWidth = lineThickness;\r\n            this.ctx.strokeStyle = \"rgba(255, 255, 0, 0.5)\";\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(this.player.x + this.player.size / 2, this.player.y + this.player.size / 2);\r\n            this.ctx.lineTo(validTarget.x + validTarget.size / 2, validTarget.y + validTarget.size / 2);\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawPlayer() {\r\n        // Draw the player rectangle        \r\n        this.ctx.fillStyle = this.player.color;\r\n        this.ctx.fillRect(this.player.x, this.player.y, this.player.size, this.player.size);\r\n    \r\n        // Draw the player's number\r\n        this.ctx.fillStyle = \"#FFFFFF\"; // Text color\r\n        this.ctx.font = \"bold 20px Arial\";\r\n        this.ctx.textAlign = \"center\";\r\n        this.ctx.textBaseline = \"middle\";\r\n        this.ctx.fillText(\r\n            this.player.number,\r\n            this.player.x + this.player.size / 2,\r\n            this.player.y + this.player.size / 2\r\n        );\r\n    }\r\n\r\n    updatePlayerState(target) {\r\n        // Update player's color by blending with the target's color\r\n        this.player.color = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.mixColors)(this.player.color, target.color);\r\n        // Update player's number to the target's number\r\n        this.player.number = target.number;\r\n    }\r\n    \r\n\r\n    checkCollisions() {\r\n        // Filter targets and process collisions\r\n        this.targets = this.targets.filter(target => {\r\n            if (this.isColliding(this.player, target)) {\r\n                return this.handleCollision(target); // Handle the collision and decide if the target should be removed\r\n            }\r\n            return true; // Keep targets that were not collided with\r\n        });\r\n    \r\n        // Check if all regular targets are collected\r\n        if (this.targets.every(target => target.type === 'hazard')) {\r\n            console.log('All regular targets collected, starting next level');\r\n            this.setup(); // Start the next level\r\n        }\r\n    }\r\n    \r\n    // Check if the player is colliding with a target\r\n    isColliding(player, target) {\r\n        return (\r\n            player.x < target.x + target.size &&\r\n            player.x + player.size > target.x &&\r\n            player.y < target.y + target.size &&\r\n            player.y + player.size > target.y\r\n        );\r\n    }\r\n    \r\n    // Handle what happens when a collision occurs\r\n    handleCollision(target) {\r\n        if (target.type === 'hazard') {\r\n            console.log('Collision with hazard detected');\r\n            this.endGame();\r\n            return false; // Remove the hazard after collision\r\n        }\r\n    \r\n        if (this.isValidTarget(target)) {\r\n            this.processValidCollision(target);\r\n            return false; // Remove the target after collision\r\n        } else {\r\n            console.log(`Invalid collision with target number: ${target.number}`);\r\n            target.reject(); // Apply rejection logic\r\n        }\r\n    \r\n        return true; // Keep the target if not removed\r\n    }\r\n    \r\n    // Determine if a target is valid for the player\r\n    isValidTarget(target) {\r\n        return (\r\n            target.number === this.player.number + 1 ||\r\n            target.number === this.player.number - 1\r\n        );\r\n    }\r\n\r\n    updateScoreLabel() {\r\n        const scoreLabel = document.getElementById('score');\r\n        if (scoreLabel) {\r\n            scoreLabel.textContent = `Score: ${this.score}`;\r\n        }\r\n    }\r\n    \r\n    // Handle the effects of a valid collision\r\n    processValidCollision(target) {\r\n        console.log(`Valid collision with target number: ${target.number}`);\r\n        this.score++;\r\n        this.updateScoreLabel();\r\n        this.updatePlayerState(target);\r\n    \r\n        // Add particle effects\r\n        for (let i = 0; i < 10; i++) {\r\n            this.particles.push(new _particle_js__WEBPACK_IMPORTED_MODULE_2__.Particle(target.x + target.size / 2, target.y + target.size / 2, target.color));\r\n        }\r\n    }\r\n    \r\n\r\n    gameLoop() {\r\n        if (!this.gameActive) return;\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Clear previous frame\r\n    \r\n        this.targets.forEach((target) => {\r\n            target.update(this.player);\r\n            target.draw(this.ctx);\r\n        });\r\n    \r\n        this.updateParticles();\r\n        this.drawParticles();\r\n        this.drawHintLine();\r\n        this.drawPlayer();\r\n    \r\n        requestAnimationFrame(() => this.gameLoop());\r\n    }\r\n    \r\n}\r\n\r\n// At the end of the init.js file, after the Game class definition\r\nif ( false || window.location.search.includes('test=true')) {\r\n    console.log(\"Exposing test functions for Playwright...\");\r\n    window.testFunctions = {\r\n        isColliding: (player, target) => {\r\n            return (\r\n                player.x < target.x + target.size &&\r\n                player.x + player.size > target.x &&\r\n                player.y < target.y + target.size &&\r\n                player.y + player.size > target.y\r\n            );\r\n        },\r\n        isValidTarget: (player, target) => {\r\n            return target.number === player.number + 1 || target.number === player.number - 1;\r\n        },\r\n        handleCollision: function (target) {\r\n            const game = this; // Use the current game context\r\n            if (target.type === 'hazard') {\r\n                console.log('Collision with hazard detected');\r\n                game.endGame();\r\n                return false;\r\n            }\r\n\r\n            if (game.isValidTarget(game.player, target)) {\r\n                console.log(`Valid collision with target: ${JSON.stringify(target)}`);\r\n                game.updatePlayerState(target);\r\n                game.score++;\r\n                for (let i = 0; i < 10; i++) {\r\n                    game.particles.push(new _particle_js__WEBPACK_IMPORTED_MODULE_2__.Particle(target.x, target.y, target.color));\r\n                }\r\n                return false; // Remove the target\r\n            } else {\r\n                console.log(`Invalid collision with target: ${JSON.stringify(target)}`);\r\n                target.reject();\r\n                return true; // Keep the target\r\n            }\r\n        },\r\n        checkCollisions: function () {\r\n            const game = this; // Use the current game context\r\n            game.targets = game.targets.filter(target => {\r\n                if (game.isColliding(game.player, target)) {\r\n                    return game.handleCollision(target);\r\n                }\r\n                return true;\r\n            });\r\n\r\n            if (game.targets.every(target => target.type === 'hazard')) {\r\n                console.log('All regular targets collected, starting next level');\r\n                game.setup();\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nwindow.onload = () => {\r\n    console.log('Window loaded, initializing game');\r\n    const gameInstance = new Game();\r\n    if (window.location.search.includes('test=true')) {\r\n        console.log('Test mode detected. Exposing game instance.');\r\n        window.game = gameInstance; // Expose the game instance for tests\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://colorgame/./scripts/init.js?");

/***/ }),

/***/ "./scripts/particle.js":
/*!*****************************!*\
  !*** ./scripts/particle.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Particle: () => (/* binding */ Particle)\n/* harmony export */ });\nclass Particle {\r\n    constructor(x, y, color) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.color = color;\r\n        this.size = Math.random() * 5 + 2;\r\n        this.dx = (Math.random() - 0.5) * 5;\r\n        this.dy = (Math.random() - 0.5) * 5;\r\n        this.life = 1; // Lifetime of the particle\r\n    }\r\n\r\n    update() {\r\n        this.x += this.dx;\r\n        this.y += this.dy;\r\n        this.life -= 0.02; // Fades over time\r\n    }\r\n\r\n    draw(ctx) {\r\n        if (this.life > 0) {\r\n            ctx.globalAlpha = this.life;\r\n            ctx.fillStyle = this.color;\r\n            ctx.beginPath();\r\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.globalAlpha = 1.0; // Reset alpha\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://colorgame/./scripts/particle.js?");

/***/ }),

/***/ "./scripts/target.js":
/*!***************************!*\
  !*** ./scripts/target.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Target: () => (/* binding */ Target)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./scripts/helpers.js\");\n\r\n\r\nclass Target {\r\n    constructor(canvas, speed, colorObj, type = 'regular', x = null, y = null) {\r\n        this.canvas = canvas;\r\n        this.size = 40;\r\n        this.baseSpeed = speed;\r\n        this.speedMultiplier = 1;\r\n        this.rejectDecayRate = 0.05;\r\n        this.color = colorObj.color;\r\n        this.number = colorObj.number;\r\n        this.type = type;\r\n        this.shape = type === 'regular' ? ['circle', 'rectangle', 'triangle', 'cloud'][Math.floor(Math.random() * 4)] : 'rectangle';\r\n        this.scale = 1;\r\n        this.isGlowing = false;\r\n    \r\n        if (x !== null && y !== null) {\r\n            this.x = x;\r\n            this.y = y;\r\n        } else {\r\n            this.spawn();\r\n        }\r\n    \r\n        this.dx = (Math.random() - 0.5) * this.baseSpeed;\r\n        this.dy = (Math.random() - 0.5) * this.baseSpeed;\r\n    }\r\n    \r\n    \r\n    \r\n\r\n    spawn() {\r\n        const margin = 50;\r\n        this.x = margin + Math.random() * (this.canvas.width - this.size - margin * 2);\r\n        this.y = margin + Math.random() * (this.canvas.height - this.size - margin * 2);\r\n        this.dx = (Math.random() - 0.5) * this.baseSpeed;\r\n        this.dy = (Math.random() - 0.5) * this.baseSpeed;\r\n    }\r\n\r\n    reject() {\r\n        this.speedMultiplier = Math.min(this.speedMultiplier + 1.2, 3); // Increment and cap speedMultiplier at 3\r\n        this.scale = 1.3; // Slightly enlarge for bounce effect\r\n    }\r\n\r\n    update(player) {\r\n        // Gradually restore the speed multiplier and scale\r\n        this.speedMultiplier = Math.max(1, this.speedMultiplier - this.rejectDecayRate);\r\n        this.scale = Math.max(1, this.scale - 0.05);\r\n\r\n        // Check if the target should glow (proximity to player number)\r\n        if (this.type === 'regular') {\r\n            this.isGlowing = Math.abs(this.number - player.number) === 1;\r\n        }\r\n\r\n        // Apply velocity with multiplier\r\n        this.x += this.dx * this.speedMultiplier;\r\n        this.y += this.dy * this.speedMultiplier;\r\n\r\n        // Bounce off walls\r\n        if (this.x <= 0 || this.x + this.size >= this.canvas.width) {\r\n            this.dx *= -1;\r\n            this.x = Math.max(0, Math.min(this.x, this.canvas.width - this.size));\r\n        }\r\n        if (this.y <= 0 || this.y + this.size >= this.canvas.height) {\r\n            this.dy *= -1;\r\n            this.y = Math.max(0, Math.min(this.y, this.canvas.height - this.size));\r\n        }\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n        ctx.translate(this.x + this.size / 2, this.y + this.size / 2);\r\n        ctx.scale(this.scale, this.scale);\r\n        ctx.translate(-(this.x + this.size / 2), -(this.y + this.size / 2));\r\n    \r\n        ctx.fillStyle = this.color;\r\n    \r\n        let textX = this.x + this.size / 2;\r\n        let textY = this.y + this.size / 2;\r\n    \r\n        switch (this.shape) {\r\n            case 'circle':\r\n                ctx.beginPath();\r\n                ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size / 2, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                break;\r\n    \r\n            case 'rectangle':\r\n                ctx.fillRect(this.x, this.y, this.size, this.size);\r\n                break;\r\n    \r\n            case 'triangle':\r\n                const centroid = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.drawTriangle)(ctx, this.x + this.size / 2, this.y + this.size / 2, this.size);\r\n                textX = centroid.centroidX;\r\n                textY = centroid.centroidY;\r\n                break;    \r\n    \r\n            case 'cloud':\r\n                (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.drawCloud)(ctx, this.x + this.size / 2, this.y + this.size / 2, this.size / 2);\r\n                break;\r\n        }\r\n    \r\n        // Draw number if regular target\r\n        if (this.type === 'regular') {\r\n            ctx.fillStyle = \"#FFFFFF\";\r\n            ctx.font = \"bold 20px Arial\";\r\n            ctx.textAlign = \"center\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.fillText(this.number, textX, textY);\r\n        }\r\n    \r\n        ctx.restore();\r\n    }\r\n    \r\n    \r\n}\r\n\n\n//# sourceURL=webpack://colorgame/./scripts/target.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./scripts/init.js");
/******/ 	
/******/ })()
;